services:

  ### --- VPN & Download Stack --- ###

  vpn:
    image: haugene/transmission-openvpn
    container_name: vpn
    env_file: .env
    cap_add:
      - NET_ADMIN
    security_opt:
      - label=disable
    devices:
      - /dev/net/tun
    environment:
      - OPENVPN_PROVIDER=${OPENVPN_PROVIDER}
      - OPENVPN_CONFIG=${OPENVPN_CONFIG}
      - LOCAL_NETWORK=${LOCAL_NETWORK}
      - KILL_SWITCH=on
      - UFW_ALLOW_GW_NET=true
      - VPN_DISABLE_IPV6=true
#      - ADDITIONAL_PORTS=8112,58846
    ports:
      - "192.168.2.38:8112:8112"       # Deluge Web UI (restreint à l'IP LAN)
      - "192.168.2.38:58846:58846" 
    volumes:
      - ${ROOT}/config/vpn:/config
      - /etc/localtime:/etc/localtime:ro
    restart: unless-stopped

  deluge:
    image: linuxserver/deluge:latest
    container_name: deluge
    network_mode: service:vpn
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${ROOT}/config/deluge:/config
      - /mnt/media/extra/downloads:/downloads
      - /mnt/media/extra/downloads/torrent-blackhole:/downloads/torrent-blackhole
    restart: unless-stopped
    depends_on:
      - vpn
    labels:
      - autoheal=true
    # Limites de ressources (compatibles docker compose)
    cpus: "1.0"
    mem_limit: "2g"
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS -o /dev/null -w '%{http_code}' http://127.0.0.1:8112/ | grep -q 200"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 90s



  jackett:
    image: linuxserver/jackett:latest
    container_name: jackett
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    ports:
      - 9117:9117
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${ROOT}/downloads/torrent-blackhole:/downloads
      - ${ROOT}/config/jackett:/config
    restart: unless-stopped

  ### --- Media Server --- ###

  plex-server:
    image: plexinc/pms-docker:latest
    container_name: plex-server
    network_mode: host
    environment:
      - TZ=${TZ}
      - PLEX_CLAIM=${PLEX_CLAIM}
    volumes:
      - ${ROOT}/config/plex/db:/config
      - ${ROOT}/config/plex/transcode:/transcode
      - /mnt/media:/mnt/media
      - /mnt/media/extra:/mnt/media/extra
    devices:
      - /dev/dri:/dev/dri
    restart: unless-stopped

  #  tdarr:
  #    image: ghcr.io/haveagitgat/tdarr:latest
  #    container_name: tdarr
  #    restart: unless-stopped
  #    ports:
  #      - "8265:8265"   # Web UI
  #      - "8266:8266"   # Server Port
  #    environment:
  #      - PUID=${PUID}
  #      - PGID=${PGID}
  #      - TZ=${TZ}
  #      - serverIP=192.168.3.39 
  #      - serverPort=8266
  #    networks:
  #      tdarr-net:
  #        aliases:
  #          - tdarr
  #    volumes:
  #      - /mnt/media:/mnt/media
  #      - ${ROOT}/config/tdarr:/app/configs
  #      - ${ROOT}/config/tdarr/server:/app/server
  #      - ${ROOT}/config/tdarr/client:/app/client


  #  tdarr_node:
  #    image: ghcr.io/haveagitgat/tdarr_node:latest
  #    container_name: tdarr_node
  #    restart: unless-stopped
  #    environment:
  #      - PUID=${PUID}
  #      - PGID=${PGID}
  #      - TZ=${TZ}
  #      - nodeID=MyNode
  #      - serverURL=http://tdarr:8266
  #    ports: []
  #    networks:
  #      - tdarr-net
  #    volumes:
  #      - /mnt/media:/mnt/media
  #      - ${ROOT}/config/tdarr/server:/app/server
  #      - ${ROOT}/config/tdarr/client:/app/client
  #    cpus: 1.5

  radarr:
    image: linuxserver/radarr:latest
    container_name: radarr
    network_mode: host
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${ROOT}/config/radarr:/config
      - /mnt/media/movies:/movies
      - /mnt/media/extra:/mnt/media/extra
      - /mnt/media/extra/downloads:/downloads
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:7878/ >/dev/null || exit 1"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s

  sonarr:
    image: linuxserver/sonarr:latest
    container_name: sonarr
    network_mode: host
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${ROOT}/config/sonarr:/config
      - /mnt/media/tv:/tv
      - /mnt/media/extra:/mnt/media/extra
      - /mnt/media/extra/downloads:/downloads
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:8989/ >/dev/null || exit 1"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 60s

  pulsarr:
    image: lakker/pulsarr:latest
    container_name: pulsarr
    network_mode: host
    environment:
      - NODE_ARGS=--log-both
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      - NODE_ARGS=--log-both
    volumes:
      - ${ROOT}/config/pulsarr:/app/data      # base de données, logs
    restart: unless-stopped

  bazarr:
    image: linuxserver/bazarr:latest
    container_name: bazarr
    network_mode: host
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - ${ROOT}/config/bazarr:/config
      - /mnt/media/movies:/movies
      - /mnt/media/tv:/tv
    restart: unless-stopped

  ### --- Web Reverse Proxy (NGINX) --- ###

  nginx:
    image: nginx:alpine
    container_name: nginx-proxy
    network_mode: host
    env_file:
      - ${ROOT}/.env
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
    volumes:
      - ${ROOT}/proxy/logs:/var/log/nginx
      - ${ROOT}/config/nginx/Plexconf:/etc/nginx/conf.d
      - ${ROOT}/config/nginx/SSL_certificate:/etc/nginx/SSL_certificate
      - ${ROOT}/config/nginx/letsencrypt/live:/etc/letsencrypt/live
      - ${ROOT}/config/nginx/letsencrypt/archive:/etc/letsencrypt/archive
      - ${ROOT}/config/nginx/letsencrypt/ssl-dhparams.pem:/etc/letsencrypt/ssl-dhparams.pem
      - ${ROOT}/config/nginx/www:/var/www/certbot
    dns:
      - 1.1.1.1
      - 8.8.8.8
    restart: unless-stopped

  certbot:
    image: certbot/certbot:latest
    container_name: certbot
    depends_on:
      - nginx
    volumes:
      - ${ROOT}/config/nginx/letsencrypt:/etc/letsencrypt
      - ${ROOT}/config/nginx/www:/var/www/certbot
      # on partage un petit fichier "stamp" pour signaler un renouvellement
      - ${ROOT}/config/nginx/reload-flag:/reload-flag
    entrypoint: /bin/sh -c
    command: >
      "trap exit TERM; while :; do
         certbot renew --quiet --webroot -w /var/www/certbot
         # si un cert a été renouvelé, certbot met à jour les dates des fichiers
         # on dépose un flag que le sidecar va voir
         date > /reload-flag/please-reload.txt
         sleep 12h;
       done"
    restart: unless-stopped

  nginx-reloader:
    image: alpine:3.20
    container_name: nginx-reloader
    depends_on:
      - nginx
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ${ROOT}/config/nginx/reload-flag:/reload-flag
    entrypoint: /bin/sh -c
    command: >
      "apk add --no-cache docker-cli inotify-tools >/dev/null 2>&1 || true;
       touch /reload-flag/please-reload.txt;
       while inotifywait -e modify,create,close_write,move /reload-flag/please-reload.txt >/dev/null 2>&1; do
         echo '[reloader] Reload nginx-proxy...';
         docker exec nginx-proxy nginx -t && docker exec nginx-proxy nginx -s reload || true;
       done"
    restart: unless-stopped
  
  monitor:
    build:
      context: ${ROOT}/scripts
      dockerfile: Dockerfile
    env_file:
      - ${ROOT}/.env
    volumes:
      - ${ROOT}/scripts/core:/app
      - ${ROOT}/config/deluge:/app/config/deluge
      - ${ROOT}/scripts/discord:/app/discord
      #      - ${ROOT}/scripts/monitor/alerts:/app/alerts
      - ${ROOT}/config/plex/transcode/Transcode:/app/Transcode
      - /mnt/data:/mnt/data
      - /var/run/docker.sock:/var/run/docker.sock
      - /mnt/media:/mnt/media
      - /mnt/media/extra:/mnt/media/extra
      - ${ROOT}/.env:/app/.env:ro
    dns:
      - 1.1.1.1     # Cloudflare
      - 8.8.8.8     # Google      
    command: ["python3", "/app/monitor_loop.py"]
    network_mode: host
    restart: unless-stopped

  add-bot: 
    build:
      context: ${ROOT}/scripts
      dockerfile: Dockerfile
    env_file:
      - ${ROOT}/.env
    volumes:
      - /mnt/data:/mnt/data
      - ${ROOT}/scripts/tool:/app/tool
    network_mode: host
    restart: unless-stopped

  discord-bot:
    build:
      context: ${ROOT}/scripts
      dockerfile: Dockerfile
    env_file:
      - ${ROOT}/.env
    volumes:  
      - /mnt/data:/mnt/data
      - ${ROOT}/scripts/core:/app/core
      - ${ROOT}/scripts/discord:/app/discord
      #- ${ROOT}/scripts/core/health:/app/health
      #- ${ROOT}/scripts/monitor/repair:/app/repair
      - ${ROOT}/scripts/monitor:/app/monitor
      - ${ROOT}/scripts/monitor/alerts:/app/alerts
      - ${ROOT}/scripts/addmedia:/app/addmedia
      - ${ROOT}/scripts/adduser:/app/adduser
      - ${ROOT}/scripts/requirements.txt:/app/requirements.txt
      - /var/run/docker.sock:/var/run/docker.sock
      - ${ROOT}/.env:/app/.env:ro
    command: ["python3", "/app/discord/discord_listener.py"]
    restart: unless-stopped
    network_mode: host

  autoheal:
    image: willfarrell/autoheal:latest
    container_name: autoheal
    restart: unless-stopped
    environment:
      - AUTOHEAL_CONTAINER_LABEL=all         # Surveille tous les containers avec un healthcheck
      - AUTOHEAL_INTERVAL=60                 # Vérifie toutes les 60 secondes
      - AUTOHEAL_START_PERIOD=300            # Délai avant de surveiller au démarrage
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - default

  #  watchtower:
  #    image: containrrr/watchtower
  #    container_name: watchtower
  #    restart: unless-stopped
  #    environment:
  #      - WATCHTOWER_CLEANUP=true              # Supprime les anciennes images
  #      - WATCHTOWER_REMOVE_VOLUMES=false      # Ne touche pas aux volumes
  #      - WATCHTOWER_POLL_INTERVAL=21600       # Vérifie toutes les 6h (en secondes)
  #      - WATCHTOWER_NOTIFICATIONS=discord     # Envoie notifications Discord
  #      - WATCHTOWER_NOTIFICATION_DISCORD_HOOK_URL=${DISCORD_WEBHOOK_URL}
  #      - TZ=${TZ}
  #    volumes:
  #      - /var/run/docker.sock:/var/run/docker.sock
  #    networks:
  #      - default
  wireguard:
    image: linuxserver/wireguard:latest
    container_name: wireguard
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    environment:
      - PUID=${PUID}
      - PGID=${PGID}
      - TZ=${TZ}
      # --- WireGuard (depuis ton .env) ---
      - SERVERURL=${SERVERURL}             # IP publique, pas de DynDNS
      - SERVERPORT=${SERVERPORT}
      - PEERS=${PEERS}
      - PEERDNS=${PEERDNS}
      - INTERNAL_SUBNET=${INTERNAL_SUBNET}
      - PEER_ALLOWEDIPS=${PEER_ALLOWEDIPS}
    volumes:
      - ${ROOT}/config/wireguard:/config
      - /lib/modules:/lib/modules:ro
    # Expose le port UDP WireGuard
    ports:
      - "${SERVERPORT}:${SERVERPORT}/udp"
    # Nécessaire au marquage fw (routing WG)
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    restart: unless-stopped


networks:
  monitoring:
    driver: bridge
  tdarr-net:
    driver: bridge

volumes:
  prometheus-data:
